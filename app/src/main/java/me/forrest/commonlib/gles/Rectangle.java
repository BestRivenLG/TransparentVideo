package me.forrest.commonlib.gles;import android.opengl.GLES20;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.nio.FloatBuffer;/** * 绘制矩形纹理的工具类 */public class Rectangle {    private static String TAG = "Rectangle";    private static final int GL_TEXTURE_EXTERNAL_OES = 0x8D65;    private static final int FLOAT_SIZE_BYTES = 4;    private static final int VERTICES_DATA_STRIDE_BYTES = 5 * FLOAT_SIZE_BYTES;    private static final int VERTICES_DATA_POS_OFFSET = 0;    private static final int VERTICES_DATA_UV_OFFSET = 3;    private FloatBuffer mVertices;    private int mProgram;    private int mPositionHandle;    private int mTextureHandle;    private int mMVPMatrixHandle;    private int mSTMatrixHandle;    // 记录Texture类型 TEXTURE_2D / GL_TEXTURE_EXTERNAL_OES    private int mTextureTarget;    public enum ShaderType {        TEXTURE_2D_Simple,          // 普通纹理 不带矩阵运算的顶点shader        TEXTURE_OES_Simple,         // OES纹理 不带矩阵运算的顶点shader        TEXTURE_2D_Matrix,          // 普通纹理 带矩阵运算的顶点shader        TEXTURE_OES_Matrix,         // OES纹理 带矩阵运算的顶点shader        TEXTURE_OES_Matrix_TRANS,   // OES纹理 带矩阵运算的顶点shader 可以处理成透明视频的片元shader        TEXTURE_EXT_BW,        TEXTURE_EXT_FILT    }    private final static String VERTEX_SHADER_SIMPLE =        "attribute vec4 aPosition;                              \n" +        "attribute vec2 aTextureCoord;                          \n" +        "varying vec2 vTextureCoord;                            \n" +        "void main() {                                          \n" +        "  gl_Position = aPosition;                             \n" +        "  vTextureCoord = aTextureCoord;                       \n" +        "}                                                      \n";    private final static String VERTEX_SHADER_MATRIX =        "uniform mat4 uMVPMatrix;                               \n" +        "uniform mat4 uSTMatrix;                                \n" +        "attribute vec4 aPosition;                              \n" +        "attribute vec4 aTextureCoord;                          \n" +        "varying vec2 vTextureCoord;                            \n" +        "void main() {                                          \n" +        "  gl_Position = uMVPMatrix * aPosition;                \n" +        "  vTextureCoord = (uSTMatrix * aTextureCoord).xy;      \n" +        "}                                                      \n";    private final static String FRAGMENT_SHADER_2D =        "precision mediump float;                               \n" +        "varying vec2 vTextureCoord;                            \n" +        "uniform sampler2D sTexture;                            \n" +        "void main() {                                          \n" +        "  gl_FragColor = texture2D(sTexture, vTextureCoord);   \n" +        "}                                                      \n";    private final static String FRAGMENT_SHADER_OES =        "#extension GL_OES_EGL_image_external : require         \n" +        "precision mediump float;                               \n" +        "varying vec2 vTextureCoord;                            \n" +        "uniform samplerExternalOES sTexture;                   \n" +        "void main() {                                          \n" +        "  gl_FragColor = texture2D(sTexture, vTextureCoord);   \n" +        "}                                                      \n";    // 绘制透明视频    private final static String FRAGMENT_SHADER_OES_TRANS =        "#extension GL_OES_EGL_image_external : require                                                     \n" +        "precision mediump float;                                                                           \n" +        "varying vec2 vTextureCoord;                                                                        \n" +        "uniform samplerExternalOES sTexture;                                                               \n" +        "void main() {                                                                                      \n" +        "  vec4 tc1 = texture2D(sTexture, vec2(vTextureCoord.s/2.0, vTextureCoord.t));                      \n" +        "  vec4 tc2 = texture2D(sTexture, vec2(vTextureCoord.s/2.0 + 0.5, vTextureCoord.t));                \n" +        "  gl_FragColor = vec4(tc1.rgb, tc2.r);                                                             \n" +        "}                                                                                                  \n";    //"  gl_FragColor = vec4( texture2D(sTexture, vec2(vTextureCoord.s/2.0, vTextureCoord.t)).rgb, 0.0 );     \n" + //texture2D(sTexture, vec2(1.0 - vTextureCoord.s/2.0, vTextureCoord.t)).r);   \n" +    private final float[] mVerticesData = {            // X, Y, Z, U, V            -1.0f,  1.0f, 0.0f,  // Position 0 左上            0.0f,  0.0f,         // TexCoord 0            -1.0f, -1.0f, 0.0f,  // Position 1 左下            0.0f,  1.0f,         // TexCoord 1            1.0f,  1.0f, 0.0f,   // Position 2 右上            1.0f,  0.0f,         // TexCoord 2            1.0f, -1.0f, 0.0f,   // Position 3            1.0f,  1.0f,         // TexCoord 3 右下    };//    private final float[] mVerticesData = {//            // X, Y, Z, U, V//            -1.0f,  1.0f, 0.0f,  // Position 0 左上//            0.0f,  1.0f,         // TexCoord 0////            -1.0f, -1.0f, 0.0f,  // Position 1 左下//            0.0f,  0.0f,         // TexCoord 1////            1.0f,  1.0f, 0.0f,   // Position 2 右上//            1.0f,  1.0f,         // TexCoord 2////            1.0f, -1.0f, 0.0f,   // Position 3//            1.0f,  0.0f,         // TexCoord 3 右下//    };    public void init(ShaderType type) {        mVertices = ByteBuffer.allocateDirect(mVerticesData.length * FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();        mVertices.put(mVerticesData).position(0);        switch (type) {            case TEXTURE_2D_Simple:                mTextureTarget = GLES20.GL_TEXTURE_2D;                mProgram = GlUtil.createProgram(VERTEX_SHADER_SIMPLE, FRAGMENT_SHADER_2D);                break;            case TEXTURE_OES_Simple:                mTextureTarget = GL_TEXTURE_EXTERNAL_OES;                mProgram = GlUtil.createProgram(VERTEX_SHADER_SIMPLE, FRAGMENT_SHADER_OES);                break;            case TEXTURE_2D_Matrix:                mTextureTarget = GLES20.GL_TEXTURE_2D;                mProgram = GlUtil.createProgram(VERTEX_SHADER_MATRIX, FRAGMENT_SHADER_2D);                break;            case TEXTURE_OES_Matrix:                mTextureTarget = GL_TEXTURE_EXTERNAL_OES;                mProgram = GlUtil.createProgram(VERTEX_SHADER_MATRIX, FRAGMENT_SHADER_OES);                break;            case TEXTURE_OES_Matrix_TRANS:                mTextureTarget = GL_TEXTURE_EXTERNAL_OES;                mProgram = GlUtil.createProgram(VERTEX_SHADER_MATRIX, FRAGMENT_SHADER_OES_TRANS);                break;        }        mPositionHandle = GLES20.glGetAttribLocation(mProgram, "aPosition");        GlUtil.checkGlError("glGetAttribLocation aPosition");        mTextureHandle = GLES20.glGetAttribLocation(mProgram, "aTextureCoord");        GlUtil.checkGlError("glGetAttribLocation aTextureCoord");        mMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, "uMVPMatrix");        mSTMatrixHandle = GLES20.glGetUniformLocation(mProgram, "uSTMatrix");    }    public void drawSelf(int textureId) {        GLES20.glUseProgram(mProgram);        GlUtil.checkGlError("glUseProgram");        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);        GLES20.glBindTexture(mTextureTarget, textureId);        mVertices.position(VERTICES_DATA_POS_OFFSET);        GLES20.glVertexAttribPointer(mPositionHandle, 3, GLES20.GL_FLOAT, false, VERTICES_DATA_STRIDE_BYTES, mVertices);        GlUtil.checkGlError("glVertexAttribPointer maPosition");        GLES20.glEnableVertexAttribArray(mPositionHandle);        GlUtil.checkGlError("glEnableVertexAttribArray maPositionHandle");        mVertices.position(VERTICES_DATA_UV_OFFSET);        GLES20.glVertexAttribPointer(mTextureHandle, 2, GLES20.GL_FLOAT, false, VERTICES_DATA_STRIDE_BYTES, mVertices);        GlUtil.checkGlError("glVertexAttribPointer maTextureHandle");        GLES20.glEnableVertexAttribArray(mTextureHandle);        GlUtil.checkGlError("glEnableVertexAttribArray maTextureHandle");        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);        GlUtil.checkGlError("glDrawArrays");    }    public void drawSelf(int textureId, float[] mvpMatrix, float[] stMatrix) {        GLES20.glUseProgram(mProgram);        GlUtil.checkGlError("glUseProgram");        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);        GLES20.glBindTexture(mTextureTarget, textureId);        // Copy the model / view / projection matrix over.        GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mvpMatrix, 0);        GlUtil.checkGlError("glUniformMatrix4fv");        // Copy the texture transformation matrix over.        GLES20.glUniformMatrix4fv(mSTMatrixHandle, 1, false, stMatrix, 0);        GlUtil.checkGlError("glUniformMatrix4fv");        mVertices.position(VERTICES_DATA_POS_OFFSET);        GLES20.glVertexAttribPointer(mPositionHandle, 3, GLES20.GL_FLOAT, false, VERTICES_DATA_STRIDE_BYTES, mVertices);        GlUtil.checkGlError("glVertexAttribPointer maPosition");        GLES20.glEnableVertexAttribArray(mPositionHandle);        GlUtil.checkGlError("glEnableVertexAttribArray maPositionHandle");        mVertices.position(VERTICES_DATA_UV_OFFSET);        GLES20.glVertexAttribPointer(mTextureHandle, 2, GLES20.GL_FLOAT, false, VERTICES_DATA_STRIDE_BYTES, mVertices);        GlUtil.checkGlError("glVertexAttribPointer maTextureHandle");        GLES20.glEnableVertexAttribArray(mTextureHandle);        GlUtil.checkGlError("glEnableVertexAttribArray maTextureHandle");        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);        GlUtil.checkGlError("glDrawArrays");    }    public void release() {        GLES20.glDeleteProgram(mProgram);        mProgram = -1;    }}